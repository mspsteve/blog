---
sidebarDepth: 0
---

# 秒杀系统设计

[[toc]]

## 秒杀概念

   **秒杀本质上是解决并发读和并发写问题**

- 并发读要保证系统尽可能少地读取数据或者尽可能少到服务器请求数据
- 单独在数据库层面设计表
- 要设计兜底方案，避免异常情况出现

## 实现目标

- 高性能 支持高并发，设计数据的动静分离方案、热点的发现与隔离、分层过滤、服务端的极致优化
- 一致性 保证高并发情况下，库存扣减要保证数据的准确性
- 高可用 要设计兜底方案

## 架构原则

- 数据要尽量少 上传给系统的数据和系统返回给用户的数据（通常就是网页）
  - 数据在网络上传输需要时间
  - 服务器在写网络时对数据进行压缩和字符编码，耗CPU
  - 系统依赖的数据能少就少
- 请求数要尽量少 合并CSS和JS文件，拼接url，服务器端做解析
- 路径要尽量短 合并部署多个相互强依赖的应用，把RPC调用转化为JVM内部调用
- 依赖要尽量少 完成一次用户请求必须强依赖的系统或者服务，设计不同系统级别，减少不同系统级别间调用
- 不要有单点 尽可能消除服务和机器的绑定关系，保证服务无状态化

## 实现方案

  **秒杀的场景中，对于系统的要求其实就三个字：快、准、稳**

- 数据的动静分离 动态数据的实质：是否跟访问者相关的个性化数据
  - 静态数据缓存到离用户最近的地方：浏览器、CDN以及缓存
  - 静态化改造就是要直接缓存HTTP连接
  - web服务器来做缓存：Nginx、Apache、Varnish
- 如何做动静分离的改造
  - URL 唯一化
  - 分离浏览者相关的因素。浏览者相关的因素包括用户登录信息，动态获取
  - 分离时间因素。服务端输出的时间也通过动态请求获取
  - 异步化地域因素。详情页面上与地域相关的因素做成异步方式获取。
  - 去掉Cookie

## 热点数据处理
   **如何发现热点数据，处理热点数据是解决秒杀系统的关键**
- 发现热点数据
  - 近实时统计热点数据 收集全链路的日志，离线分析top N数据
  - 提前离线统计出数据
- 处理热点数据
  - 优化，使用缓存队列，设置超时时间
  - 限制，使用一致性hash方法，根据hash做分桶，分桶设置处理队列，保证非热点数据的请求处理
  - 隔离，业务隔离、系统隔离、以及数据隔离

## 流量削峰

   **请求数尽可能少**

   - 排队异步策略 内部上下游系统之间调用请求不平缓的场景
     - 消息队列方式
     - 利用线程池加锁等待
     - 先进先出、先进后出等常用的内存排队算法
     - 把请求序列化到文件中，然后再顺序地读文件（例如基于mysql binlog同步机制）来恢复请求等方式
   - 答题延缓策略 更适用于秒杀或者营销活动等应用场景
     - 防止部分买家使用秒杀器在参加秒杀时作弊
     - 目的其实就是延缓请求
   - 分层过滤策略 非常适合交易性的写请求
     - 将动态请求的读数据缓存（cache）在web端，过滤掉无效的数据读
     - 对读数据不做强一致性校验，减少因为一致性校验产生瓶颈的问题
     - 对写数据进行基于时间的合理分片，过滤掉过期的失效请求
     - 对写请求做限流保护，将超出系统承载能力的请求过滤掉
     - 对写数据进行强一致性校验，只保留最后有效的数据

## 性能优化

   **使用QPS来衡量系统服务端性能 总QPS =（1000ms/响应时间）× 线程数量**

   - 设置合理的线程数，最大化CPU使用，可以显著提升服务器性能
   > 线程数 = [(线程等待时间 + 线程 CPU 时间) / 线程 CPU 时间] × CPU 数量

   > 线程数 = 2*CPU数量 + 1 默认值
   - 判断CPU性能瓶颈 JProfiler 和 Yourkit
   - 系统优化
     - 较少编码 字符串IO操作，字符转化为字节必须编码 resp.getOutputStream()直接执行字符操作
     - 较少序列化 必要情况较少RPC调用，直接打包部署
     - java极致优化 使用代理服务器直接返回静态数据
     - 并发读优化 借助本地缓存和缓存中间件

## 减库存操作



























