---
sidebarDepth: 0
---

# 缓存与db一致性

[[toc]]

## 前言

   更新完数据库，是更新缓存呢，还是删除缓存。又或者是先删除缓存，再更新数据库。更新和删除的先后顺序都会带来某个时间间隙的脏数据，本文旨在提供一个工程上最优解决方案。

   **本文重点**
- 讲解缓存更新策略
- 对每种策略进行缺点分析
- 针对缺点给出改进方案

## 理论方案和实现目标

设置缓存过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可，是保证最终一致性的解决方案。
数据库写成功，缓存更新失败，只要到达过期时间，后续的读请求会从数据库中读取新值更新缓存。

## 目前实现策略

### 先更新数据库，再更新缓存

 请求A和请求B同时进行更新操作，那么会出现<br>
（1）线程A更新了数据库<br>
（2）线程B更新了数据库<br>
（3）线程B更新了缓存<br>
（4）线程A更新了缓存<br>
正常情况下,(4)应该比(3)早，但是由于网络的原因，B比A早更新缓存，导致出现脏数据，导致数据变更出现不可控因素，因此实际工作上不予考虑。
此外，对于写较多的情况下，频繁地更新缓存也导致性能下降。

### 先删缓存，再更新数据库

 请求A进行更新操作，请求B进行查询操作。那么会出现如下情形:<br>
（1）请求A进行写操作时，首先删除缓存<br>
（2）请求B查询发现缓存不存在<br>
（3）请求B去数据库查询得到旧值<br>
（4）请求B将旧值写入缓存<br>
（5）请求A将新值写入数据库<br>

### 先更新数据库，再删缓存

 假设两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形：<br>
（1）缓存刚好失效<br>
（2）请求A查询数据库，得一个旧值<br>
（3）请求B将新值写入数据库<br>
（4）请求B删除缓存<br>
（5）请求A将查到的旧值写入缓存<br>
 如果发生上述情况，确实是会发生脏数据。一般情况下，读取比写入要快很多，上述情况很难发生，极端情况下发生。

## 解决方案

### 设置缓存失效时间
 理论上，合理的缓存失效时间可以有效避免脏数据发生，但是缓存失效时间不容易控制，要考虑到读写时间差以及主从数据库同步等等因素，
 同时还要避免设置时间过短导致频繁查询数据的情况。

### 延时双删策略
  首先删除缓存，延迟一段时间再删除缓存,最终清楚掉脏数据，具体**实现方案**如下：

  方案1：将删除失败的redis key放入到消息队列中，利用消息队列做重试。保证删除功能顺利实现，缺点代码侵入。<br>
  方案2: 使用canal订阅binlog日志，取出操作的数据和key，实现方案1重试功能。

## 参考文献

- [58沈剑](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=404308725&idx=1&sn=1a25ce76dd1956014ceb8a011855268e&scene=21#wechat_redirect)
- [程序员孤独烟](https://mp.weixin.qq.com/s?__biz=MzU5NjY2MzEyMA==&mid=2247483656&idx=1&sn=5668a4d9dd1fe0e028e4c1d4bcf5d427&chksm=fe5e0f37c92986218653450cd60fc88a65f29acda51c13b84602fc421786bb549f858e56aee0&scene=21#wechat_redirect)




