---
sidebarDepth: 0
---

# linux命令

[[toc]]


## 常用基础命令

### crontab命令

- crond linux循环运行的定时任务
- at命令为一次运行任务
- 文件路径：/etc/crontab
- crond表达式格式:minute   hour   day   month   week   command
- crond日志重定向 ：0 */3 * * * /usr/local/apache2/apachectl restart >/dev/null 2>&1
- crond用法

### crond用法

- crond服务

``` powershell
service crond status #查看crontab服务状态
service crond start  #手动启动crontab服务
ntsysv #查看crontab服务是否已设置为开机启动，执行命令
chkconfig –level 35 crond on #加入开机自动启动
```

- crontab命令

``` powershell
crontab -l #列出crontab文件
crontab -e #编辑crontab文件，保存后自动运行
crontab -r #删除crontab文件
crontab <filename> #恢复丢失文件
```

### awk命令

### cut命令

## 负载问题排查

### 基本概念

**平均负载**：在单位时间内，系统处于可执行状态和不可中断状态的平均进程数，也就是平均活跃进程数,实质上是指活跃进程数的指数衰减平均值。<br>

**可运行状态**：是指正在使用CPU或者正在等待CPU的进程，也就是我们用ps命令时看到的，处于R状态的进程。<br>

**不可中断状态**：是处于内核态关键流程中的进程，并且这些流程是不可以打断的，比如说常见的是等待硬件设备的I/O响应，也就是我们再ps命令中看到的D状态(`Uninterruptible Sleep`，也称为`Disk Sleep`)<br>

**平均活跃线程数**：综合上面表述，平均活跃线程数正在使用CPU的进程，还包括等待CPU和等待I/O的进程。

**CPU使用率**：单位时间内CPU繁忙情况的统计，跟平均负载并不一定完全对应。CPU密集型进程，使用大量CPU会导致平均负载升高，此时能够通过平均负载体现;I/O密集型进程，等待I/O也会导致平均负载升高，此时CPU使用率不一定高。
大量等待CPU的进程调度也会导致平均负载升高，CPU使用率也比较高。

**CPU上下文切换**：将上一个任务的CPU寄存器和程序计数器的内容保存起来，然后将新任务的上下文的内容加载到CPU寄存器和程序计数器，然后跳转到程序计数器所指的新位置，运行新任务。系统调用过程中，会发生两次CPU上下文切换。

### 排查问题思路

- 使用uptime 或者top判断系统是否过载

```linux
$ uptime
 15:39:25 up 197 days, 38 min, 11 users,  load average: 2.70, 3.34, 3.18
# 当前时间    运行天数           正在登陆用户数              1分钟  5分钟 15分钟负载
```

::::tip
  通过过去15分钟 -> 5分钟 -> 1分钟 负载的变化，说明系统负载在降低,
  实际生产环境，当平均负载高于CPU数据70%，需要分析负载过高的原因
::::

```linux
top - 14:20:05 up 211 days, 23:18,  3 users,  load average: 5.30, 3.72, 3.65
Tasks: 639 total,   2 running, 635 sleeping,   0 stopped,   2 zombie
%Cpu(s):  5.9 us,  0.6 sy,  0.0 ni, 93.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem : 13161476+total,  6327752 free, 10753504+used, 17751960 buff/cache
KiB Swap:        0 total,        0 free,        0 used. 18833468 avail Mem

   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
  8604 web_ser+  20   0  216284  28024   7756 R 101.0  0.0  14447:05 test_blob_serve
 56286 web_ser+  20   0 14.692g 4.824g   9064 S  66.1  3.8  12546:35 test_share_embe
 16055 web_ser+  20   0 4164276 2.027g   2868 S  54.2  1.6  36809:02 test_red_packet
 46902 web_ser+  20   0 20.002t 1.632g  14380 S  53.2  1.3   8998:13 test_share_retr
 11085 web_ser+  20   0 25.572g 1.090g  44872 S  32.2  0.9   1717:05 java
 72043 web_ser+  20   0 3253632 1.340g   9796 S  16.6  1.1   3024:33 test_share_caes
 78793 web_ser+  20   0 23.493g 1.674g  41512 S  11.3  1.3 219:24.07 java
 54142 web_ser+  20   0 5899060 299172  11428 S   2.0  0.2 450:33.41 test_share_serv
 58886 web_ser+  20   0 17.405g 1.966g  45620 S   1.7  1.6  83:40.31 java
 82489 web_ser+  20   0 35.817g 4.380g  13980 S   1.3  3.5 629:33.95 java
 82501 web_ser+  20   0 22.157g 2.746g  13868 S   1.3  2.2 716:36.05 java
117446 web_ser+  20   0 24.173g 1.749g  13852 S   1.3  1.4 716:24.98 java
133546 web_ser+  20   0 62.963g 4.594g  13836 S   1.3  3.7 887:04.45 java
135612 web_ser+  20   0 14.129g 1.891g  14664 S   1.3  1.5  58:31.51 java
143794 web_ser+  22   2 30.366g 5.138g  14372 S   1.3  4.1 680:40.74 java
176853 web_ser+  20   0 8920400 2.042g  14428 S   1.3  1.6   3:02.78 java
```

::::tip
第一行分别为：当前系统时间，已运行时间，用户，负载(5分钟、10分钟、15分钟)<br>
第二行分别为：任务运行时间<br>
第三行为任务的状态<br>
第四行为CPU状态：
- us, user： 运行(未调整优先级的) 用户进程的CPU时间
- sy，system: 运行内核进程的CPU时间
- ni，niced：运行已调整优先级的用户进程的CPU时间
- wa，IO wait: 用于等待IO完成的CPU时间
- hi：处理硬件中断的CPU时间
- si: 处理软件中断的CPU时间
- st：这个虚拟机被hypervisor偷去的CPU时间（译注：如果当前处于一个hypervisor下的vm，实际上hypervisor也是要消耗一部分CPU处理时间的）。
第五行为物理内存使用情况
第六行为虚拟内存使用情况
第七行为各个进程的状态监控

- PID：进程ID，进程的唯一标识符
- USER：进程所有者的实际用户名。
- PR：进程的调度优先级。这个字段的一些值是'rt'。这意味这这些进程运行在实时态。
- NI：进程的nice值（优先级）。越小的值意味着越高的优先级。负值表示高优先级，正值表示低优先级
- VIRT：进程使用的虚拟内存。进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES
- RES：驻留内存大小。驻留内存是任务使用的非交换物理内存大小。进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA
- SHR：SHR是进程使用的共享内存。共享内存大小，单位kb
- S：这个是进程的状态。它有以下不同的值:
    - D - 不可中断的睡眠态。
    - R – 运行态
    - S – 睡眠态
    - T – 被跟踪或已停止
    - Z – 僵尸态
- %CPU：自从上一次更新时到现在任务所使用的CPU时间百分比。
- %MEM：进程使用的可用物理内存百分比。
- TIME+：任务启动后到现在所使用的全部CPU时间，精确到百分之一秒。
- COMMAND：运行进程所使用的命令。进程名称（命令名/命令行）

::::

- 判断linux 系统cpu个数

```linux
$ grep 'model name' /proc/cpuinfo | wc -l
56
```

- 使用mpstat 查询CPU使用率情况，判断是否为CPU密集型还是I/O密集型,或者是线程数据过多

```linux
# -P ALL 表示监控所有 CPU，后面数字5表示间隔5s后输出一组数据
$ mpstat -P ALL 5
Linux 3.10.0-693.5.2.el7.x86_64 (bjfk-rs7369.yz02) 	2019年02月21日 	_x86_64_	(56 CPU)

15时47分11秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
15时47分15秒  all    5.12    0.02    0.68    0.02    0.00    0.01    0.00    0.00    0.00   94.15
15时47分15秒    0    3.98    0.00    1.33    0.00    0.00    0.00    0.00    0.00    0.00   94.69
15时47分15秒    1   30.71    0.00    0.52    0.00    0.00    0.00    0.00    0.00    0.00   68.77
15时47分15秒    2    4.18    0.26    1.04    0.00    0.00    0.00    0.00    0.00    0.00   94.52
15时47分15秒    3    0.52    0.00    0.26    0.00    0.00    0.00    0.00    0.00    0.00   99.21
15时47分15秒    4    6.07    0.00    1.06    0.26    0.00    0.00    0.00    0.00    0.00   92.61
15时47分15秒    5    0.52    0.00    0.26    0.00    0.00    0.00    0.00    0.00    0.00   99.21
15时47分15秒    6    4.44    0.00    1.04    0.00    0.00    0.00    0.00    0.00    0.00   94.52
15时47分15秒    7    0.26    0.00    0.26    0.00    0.00    0.00    0.00    0.00    0.00   99.48
15时47分15秒    8    2.62    0.00    0.52    0.26    0.00    0.00    0.00    0.00    0.00   96.60
15时47分15秒    9    0.52    0.00    0.26    0.00    0.00    0.00    0.00    0.00    0.00   99.21
15时47分15秒   10    2.88    0.26    0.52    0.00    0.00    0.00    0.00    0.00    0.00   96.34
……
```

::::tip
- 03:29:29 PM : 指mpstat运行的时间
- all : 指所有CPU
- %usr : 显示在用户级别（例如应用程序）执行时CPU利用率的百分比
- %nice :显示在拥有nice优先级的用户级别执行时CPU利用率的百分比
- %sys : 现实在系统级别（例如内核）执行时CPU利用率的百分比
- %iowait : 显示在系统有未完成的磁盘I/O请求期间CPU空闲时间的百分比
- %irq : 显示CPU服务硬件中断所花费时间的百分比
- %soft : 显示CPU服务软件中断所花费时间的百分比
- %steal : 显示虚拟机管理器在服务另一个虚拟处理器时虚拟CPU处在非自愿等待下花费时间的百分比
- %guest : 显示运行虚拟处理器时CPU花费时间的百分比
- %idle : 显示CPU空闲和系统没有未完成的磁盘I/O请求情况下的时间百分比
::::

- I/O密集型或者线程数量过多，使用pidstat查询iowait，确认进程(针对I/O过多或者进程争抢过大的情况无法判断)

```linux
# 间隔 5 秒后输出一组数据，-u 表示 CPU 指标
$ pidstat -u 5 1
Linux 4.15.0 (ubuntu)     09/22/18     _x86_64_    (2 CPU)
13:42:08      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
13:42:13        0       104    0.00    3.39    0.00    0.00    3.39     1  kworker/1:1H
13:42:13        0       109    0.00    0.40    0.00    0.00    0.40     0  kworker/0:1H
13:42:13        0      2997    2.00   35.53    0.00    3.99   37.52     1  stress
13:42:13        0      3057    0.00    0.40    0.00    0.00    0.40     0  pidstat

```

- 使用vmstat分析切换以及切换类型来判断I/O过多或者线程争抢过大

```linux
vmstat 1
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 4  0      0 2783080 374944 13835420    0    0     3    54    0    0  7  1 92  0  0
 3  0      0 2783412 374944 13835420    0    0     0    96 92709 50615  6  1 93  0  0
 2  0      0 2784440 374944 13835520    0    0     0     0 52740 52105  5  1 95  0  0
 4  0      0 2785980 374944 13835484    0    0     0     0 53759 48080  5  1 95  0  0
 3  0      0 2784212 374944 13835996    0    0     0    16 59296 51606  5  0 94  0  0
```

::::tip
- **r** 表示运行队列(就是说多少个进程真的分配到CPU)
- **b** 表示阻塞的进程
- swpd 虚拟内存已使用的大小
- free 空闲物理内存
- buff Linux/Unix系统是用来存储缓存
- cache 缓存文件
- si  每秒从磁盘读入虚拟内存的大小
- so  每秒虚拟内存写入磁盘的大小
- bi  块设备每秒接收的块数量,默认大小1024byte
- bo  块设备每秒发送的块数量
- **in**  每秒CPU的中断次数，包括时间中断
- **cs**  每秒上下文切换次数
- us  用户CPU时间
- sy  系统CPU时间
- id  空闲CPU时间，一般来说，id + us + sy = 100
::::
  重点分析标记4列，判断是否为CPU频繁的上下文切换导致。


- lsof（list open files）是一个查看当前系统文件的工具，也可以用于问题排查，具体见[博客](https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/lsof.html)

- top、uptime等命令只能查询出来长时间进程，短时间进程可使用perf命令查询，可以统计某个时间段内数据，使用pstree可以查询子进程

```linux
# 记录性能事件，等待大约 15 秒后按 Ctrl+C 退出
$ perf record -g

# 查看报告
$ perf report

```

- 僵尸进程如何排查

既然僵尸进程是因为父进程没有回收子进程的资源而出现的，要解决子进程的僵尸问题，需要在父进程中解决。使用pstree查看父进程，然后具体分析。

```
# -a 表示输出命令行选项
# p 表 PID
# s 表示指定进程的父进程
$ pstree -aps 3084
systemd,1
  └─dockerd,15006 -H fd://
      └─docker-containe,15024 --config /var/run/docker/containerd/containerd.toml
          └─docker-containe,3991 -namespace moby -workdir...
              └─app,4009
                  └─(app,3084)
```

- 大量不可中断的进程如何解决

不可中断状态：一般表示进程正在跟硬件交互，为了保护进程数据与硬件一致，系统不允许其他进程或中断打断该进程。<br>
使用top或者ps查看系统有多少不可中断进程，top命令中S列为D的进程，需要查看iowait是否变大。

使用dstat，观察CPU以及IO的使用情况(主要关注D状态进程)
```
# 间隔 1 秒输出 10 组数据
$ dstat 1 10
You did not select any stats, using -cdngy by default.
--total-cpu-usage-- -dsk/total- -net/total- ---paging-- ---system--
usr sys idl wai stl| read  writ| recv  send|  in   out | int   csw
  0   0  96   4   0|1219k  408k|   0     0 |   0     0 |  42   885
  0   0   2  98   0|  34M    0 | 198B  790B|   0     0 |  42   138
  0   0   0 100   0|  34M    0 |  66B  342B|   0     0 |  42   135
  0   0  84  16   0|5633k    0 |  66B  342B|   0     0 |  52   177
  0   3  39  58   0|  22M    0 |  66B  342B|   0     0 |  43   144
  0   0   0 100   0|  34M    0 | 200B  450B|   0     0 |  46   147
  0   0   2  98   0|  34M    0 |  66B  342B|   0     0 |  45   134
  0   0   0 100   0|  34M    0 |  66B  342B|   0     0 |  39   131
  0   0  83  17   0|5633k    0 |  66B  342B|   0     0 |  46   168
  0   3  39  59   0|  22M    0 |  66B  342B|   0     0 |  37   134
```

使用pidstat命令，用-p 进程号来查看进程读写情况

```
$ pidstat -d -p 123656 1 3
Linux 3.10.0-693.5.2.el7.x86_64 (bjfk-rs7369.yz02) 	2019年03月08日 	_x86_64_	(56 CPU)

17时32分21秒   UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command
17时32分22秒  1101    123656      0.00      0.00      0.00  java
17时32分23秒  1101    123656      0.00      0.00      0.00  java
17时32分24秒  1101    123656      0.00      0.00      0.00  java
平均时间:  1101    123656      0.00      0.00      0.00  java
```

借助动态工具，比如说perf命令来进一步确认

- 软中断以及软中断带来的CPU性能优化问题
  中断是一种异步的事件处理机制，用来提升系统的并发处理能力。中断事件发生会触发执行中断处理程序，中断处理程序主要分为上半部和下半部这两个部分：
  - 上半部对应硬中断，用来快速处理中断
  - 下半部对应软中断，用来异步处理上半部未完成的工作

  linux软中断包括网络收发、定时、RCU锁等各种类型，可以查看proc/softirqs观察软中断运行情况。linux系统中软中断对应软中断内核线程，软中断事件的频率过高时，
内核线程也会因为CPU使用使用率过高而导致软中断处理不及时，从而进一步导致网络收发延迟、调度缓慢等性能问题。

sar 是一个系统活动报告工具，既可以实时查看系统的当前活动，又可以配置保存和报告历史统计数据，可以从多方面对系统的活动进行报告，包括：文件的读写情况、系统调用的使用情况、磁盘I/O、CPU效率、内存使用状况、进程活动及IPC有关的活动等。<br>




hping3 是一个可以构造 TCP/IP 协议数据包的工具，可以对系统进行安全审计、防火墙测试等。<br>
tcpdump 是一个常用的网络抓包工具，常用来分析各种网络问题。<br>










