---
sidebarDepth: 0
---

# linux命令

[[toc]]


## 常用基础命令

### crontab命令

- crond linux循环运行的定时任务
- at命令为一次运行任务
- 文件路径：/etc/crontab
- crond表达式格式:minute   hour   day   month   week   command
- crond日志重定向 ：0 */3 * * * /usr/local/apache2/apachectl restart >/dev/null 2>&1
- crond用法

### crond用法

- crond服务

``` powershell
service crond status #查看crontab服务状态
service crond start  #手动启动crontab服务
ntsysv #查看crontab服务是否已设置为开机启动，执行命令
chkconfig –level 35 crond on #加入开机自动启动
```

- crontab命令

``` powershell
crontab -l #列出crontab文件
crontab -e #编辑crontab文件，保存后自动运行
crontab -r #删除crontab文件
crontab <filename> #恢复丢失文件
```

### awk命令

### cut命令

## 负载问题排查

### 基本概念

**平均负载**：在单位时间内，系统处于可执行状态和不可中断状态的平均进程数，也就是平均活跃进程数,实质上是指活跃进程数的指数衰减平均值。<br>

**可运行状态**：是指正在使用CPU或者正在等待CPU的进程，也就是我们用ps命令时看到的，处于R状态的进程。<br>

**不可中断状态**：是处于内核态关键流程中的进程，并且这些流程是不可以打断的，比如说常见的是等待硬件设备的I/O响应，也就是我们再ps命令中看到的D状态(`Uninterruptible Sleep`，也称为`Disk Sleep`)<br>

**平均活跃线程数**：综合上面表述，平均活跃线程数正在使用CPU的进程，还包括等待CPU和等待I/O的进程。

**CPU使用率**：单位时间内CPU繁忙情况的统计，跟平均负载并不一定完全对应。CPU密集型进程，使用大量CPU会导致平均负载升高，此时能够通过平均负载体现;I/O密集型进程，等待I/O也会导致平均负载升高，此时CPU使用率不一定高。
大量等待CPU的进程调度也会导致平均负载升高，CPU使用率也比较高。

**CPU上下文切换**：将上一个任务的CPU寄存器和程序计数器的内容保存起来，然后将新任务的上下文的内容加载到CPU寄存器和程序计数器，然后跳转到程序计数器所指的新位置，运行新任务。系统调用过程中，会发生两次CPU上下文切换。

### 排查问题思路

- 使用uptime 或者top判断系统是否过载

```linux
$ uptime
 15:39:25 up 197 days, 38 min, 11 users,  load average: 2.70, 3.34, 3.18
# 当前时间    运行天数           正在登陆用户数              1分钟  5分钟 15分钟负载
```

::::tip
  通过过去15分钟 -> 5分钟 -> 1分钟 负载的变化，说明系统负载在降低,
  实际生产环境，当平均负载高于CPU数据70%，需要分析负载过高的原因
::::

- 判断linux 系统cpu个数

```linux
$ grep 'model name' /proc/cpuinfo | wc -l
56
```

- 使用mpstat 查询CPU使用率情况，判断是否为CPU密集型还是I/O密集型,或者是线程数据过多

```linux
# -P ALL 表示监控所有 CPU，后面数字5表示间隔5s后输出一组数据
$ mpstat -P ALL 5
Linux 3.10.0-693.5.2.el7.x86_64 (bjfk-rs7369.yz02) 	2019年02月21日 	_x86_64_	(56 CPU)

15时47分11秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
15时47分15秒  all    5.12    0.02    0.68    0.02    0.00    0.01    0.00    0.00    0.00   94.15
15时47分15秒    0    3.98    0.00    1.33    0.00    0.00    0.00    0.00    0.00    0.00   94.69
15时47分15秒    1   30.71    0.00    0.52    0.00    0.00    0.00    0.00    0.00    0.00   68.77
15时47分15秒    2    4.18    0.26    1.04    0.00    0.00    0.00    0.00    0.00    0.00   94.52
15时47分15秒    3    0.52    0.00    0.26    0.00    0.00    0.00    0.00    0.00    0.00   99.21
15时47分15秒    4    6.07    0.00    1.06    0.26    0.00    0.00    0.00    0.00    0.00   92.61
15时47分15秒    5    0.52    0.00    0.26    0.00    0.00    0.00    0.00    0.00    0.00   99.21
15时47分15秒    6    4.44    0.00    1.04    0.00    0.00    0.00    0.00    0.00    0.00   94.52
15时47分15秒    7    0.26    0.00    0.26    0.00    0.00    0.00    0.00    0.00    0.00   99.48
15时47分15秒    8    2.62    0.00    0.52    0.26    0.00    0.00    0.00    0.00    0.00   96.60
15时47分15秒    9    0.52    0.00    0.26    0.00    0.00    0.00    0.00    0.00    0.00   99.21
15时47分15秒   10    2.88    0.26    0.52    0.00    0.00    0.00    0.00    0.00    0.00   96.34
……
```

::::tip
- 03:29:29 PM : 指mpstat运行的时间
- all : 指所有CPU
- %usr : 显示在用户级别（例如应用程序）执行时CPU利用率的百分比
- %nice :显示在拥有nice优先级的用户级别执行时CPU利用率的百分比
- %sys : 现实在系统级别（例如内核）执行时CPU利用率的百分比
- %iowait : 显示在系统有未完成的磁盘I/O请求期间CPU空闲时间的百分比
- %irq : 显示CPU服务硬件中断所花费时间的百分比
- %soft : 显示CPU服务软件中断所花费时间的百分比
- %steal : 显示虚拟机管理器在服务另一个虚拟处理器时虚拟CPU处在非自愿等待下花费时间的百分比
- %guest : 显示运行虚拟处理器时CPU花费时间的百分比
- %idle : 显示CPU空闲和系统没有未完成的磁盘I/O请求情况下的时间百分比
::::

- I/O密集型或者线程数量过多，使用pidstat查询iowait，确认进程(针对I/O过多或者进程争抢过大的情况无法判断)

```linux
# 间隔 5 秒后输出一组数据，-u 表示 CPU 指标
$ pidstat -u 5 1
Linux 4.15.0 (ubuntu)     09/22/18     _x86_64_    (2 CPU)
13:42:08      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
13:42:13        0       104    0.00    3.39    0.00    0.00    3.39     1  kworker/1:1H
13:42:13        0       109    0.00    0.40    0.00    0.00    0.40     0  kworker/0:1H
13:42:13        0      2997    2.00   35.53    0.00    3.99   37.52     1  stress
13:42:13        0      3057    0.00    0.40    0.00    0.00    0.40     0  pidstat

```

- 使用vmstat分析切换以及切换类型来判断I/O过多或者线程争抢过大

```linux
vmstat 1
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 4  0      0 2783080 374944 13835420    0    0     3    54    0    0  7  1 92  0  0
 3  0      0 2783412 374944 13835420    0    0     0    96 92709 50615  6  1 93  0  0
 2  0      0 2784440 374944 13835520    0    0     0     0 52740 52105  5  1 95  0  0
 4  0      0 2785980 374944 13835484    0    0     0     0 53759 48080  5  1 95  0  0
 3  0      0 2784212 374944 13835996    0    0     0    16 59296 51606  5  0 94  0  0
```

::::tip
- **r** 表示运行队列(就是说多少个进程真的分配到CPU)
- **b** 表示阻塞的进程
- swpd 虚拟内存已使用的大小
- free 空闲物理内存
- buff Linux/Unix系统是用来存储缓存
- cache 缓存文件
- si  每秒从磁盘读入虚拟内存的大小
- so  每秒虚拟内存写入磁盘的大小
- bi  块设备每秒接收的块数量,默认大小1024byte
- bo  块设备每秒发送的块数量
- **in**  每秒CPU的中断次数，包括时间中断
- **cs**  每秒上下文切换次数
- us  用户CPU时间
- sy  系统CPU时间
- id  空闲CPU时间，一般来说，id + us + sy = 100
::::
  重点分析标记4列，判断是否为CPU频繁的上下文切换导致。


- lsof（list open files）是一个查看当前系统文件的工具，也可以用于问题排查，具体见[博客](https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/lsof.html)

- top、uptime等命令只能查询出来长时间进程，短时间进程可使用perf命令查询，可以统计某个时间段内数据，使用pstree可以查询子进程

```linux
# 记录性能事件，等待大约 15 秒后按 Ctrl+C 退出
$ perf record -g

# 查看报告
$ perf report

```

